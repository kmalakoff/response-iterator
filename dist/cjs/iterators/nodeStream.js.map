{"version":3,"sources":["../../../src/iterators/nodeStream.ts"],"names":["hasIterator","Symbol","asyncIterator","nodeStreamIterator","stream","cleanup","error","done","data","waiting","onData","chunk","length","shift","value","push","onError","err","all","slice","forEach","pair","onEnd","undefined","removeListener","on","getNext","Promise","resolve","reject","iterator","next"],"mappings":"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","sourcesContent":["import { Readable as NodeReadableStream } from \"stream\";\n\nconst hasIterator = typeof Symbol !== \"undefined\" && Symbol.asyncIterator;\n\n/* c8 ignore start */\nexport default function nodeStreamIterator<T>(stream: NodeReadableStream): AsyncIterableIterator<T> {\n  let cleanup = null;\n  let error = null;\n  let done = false;\n  const data = [];\n  const waiting = [];\n\n  function onData(chunk) {\n    if (error) return;\n    if (waiting.length) return waiting.shift()[0]({ value: chunk, done: false });\n    data.push(chunk);\n  }\n  function onError(err) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean>> {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length) return resolve({ value: data.shift(), done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator = {\n    next(): Promise<IteratorResult<T, boolean>> {\n      return getNext();\n    },\n  };\n\n  if (hasIterator) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n/* c8 ignore stop */\n"],"file":"nodeStream.js"}