{"version":3,"file":"response-iterator.min.js","sources":["../../src/index.ts"],"sourcesContent":["import { Response as NodeResponse } from \"node-fetch\";\n\ninterface CrossResponse {\n  _bodyBlob: Blob;\n}\n\nexport interface IterableIterator<T> {\n  next(): Promise<IteratorResult<T, boolean>>;\n  [Symbol.asyncIterator](): Promise<IteratorResult<T, boolean>>;\n}\n\nfunction streamIterator<T>(stream): IterableIterator<T> {\n  const iterator = stream[Symbol.asyncIterator]();\n  return {\n    next: function (): Promise<IteratorResult<T, boolean>> {\n      return iterator.next();\n    },\n    [Symbol.asyncIterator]: function (): Promise<IteratorResult<T, boolean>> {\n      return this;\n    },\n  } as IterableIterator<T>;\n}\n\n/* c8 ignore start */\nfunction readerIterator<T>(reader): IterableIterator<T> {\n  return {\n    next: function (): Promise<IteratorResult<T, boolean>> {\n      return reader.read();\n    },\n    [Symbol.asyncIterator]: function (): Promise<IteratorResult<T, boolean>> {\n      return this;\n    },\n  } as IterableIterator<T>;\n}\n\nfunction promiseIterator<T>(promise): IterableIterator<T> {\n  let resolved = false;\n  return {\n    next: function (): Promise<IteratorResult<T, boolean>> {\n      if (resolved) return Promise.resolve({ value: undefined, done: true });\n      resolved = true;\n      return new Promise(function (resolve, reject) {\n        promise\n          .then(function (value) {\n            resolve({ value, done: false });\n          })\n          .catch(reject);\n      });\n    },\n    [Symbol.asyncIterator]: function (): Promise<IteratorResult<T, boolean>> {\n      return this;\n    },\n  } as IterableIterator<T>;\n}\n/* c8 ignore stop */\n\nexport default function responseIterator<T>(response: Response | NodeResponse | CrossResponse): IterableIterator<T> {\n  if (response === undefined) throw new Error(\"Missing response for responseIterator\");\n\n  // node-fetch\n  if ((response as NodeResponse).body && (response as NodeResponse).body[Symbol.asyncIterator] !== undefined)\n    return streamIterator<T>((response as NodeResponse).body);\n  /* c8 ignore start */\n  // browser fetch\n  else if ((response as Response).body && (response as Response).body.getReader)\n    return readerIterator<T>((response as Response).body.getReader());\n  // browser cross-fetch\n  else if ((response as CrossResponse)._bodyBlob)\n    return promiseIterator<T>((response as CrossResponse)._bodyBlob.arrayBuffer());\n  /* c8 ignore stop */\n\n  throw new Error(\"Unknown body type for responseIterator\");\n}\n"],"names":["response","undefined","Error","body","Symbol","asyncIterator","stream","iterator","next","this","getReader","reader","read","_bodyBlob","promise","arrayBuffer","resolved","Promise","resolve","value","done","reject","then","catch"],"mappings":"gXAwDe,SAA6BA,WACzBC,IAAbD,EAAwB,MAAM,IAAIE,MAAM,4CAGvCF,EAA0BG,WAAkEF,IAAzDD,EAA0BG,KAAKC,OAAOC,eAC5E,OAlDuBC,EAkDGN,EAA0BG,KAjDhDI,EAAWD,EAAOF,OAAOC,oBAE7BG,KAAM,kBACGD,EAASC,SAEjBJ,OAAOC,eAAgB,kBACfI,QA8CN,GAAKT,EAAsBG,MAASH,EAAsBG,KAAKO,UAClE,OAzCuBC,EAyCGX,EAAsBG,KAAKO,eAvCrDF,KAAM,kBACGG,EAAOC,SAEfR,OAAOC,eAAgB,kBACfI,QAqCN,GAAKT,EAA2Ba,UACnC,OAjCwBC,EAiCGd,EAA2Ba,UAAUE,cAhC9DC,GAAW,KAEbR,KAAM,kBACAQ,EAAiBC,QAAQC,QAAQ,CAAEC,WAAOlB,EAAWmB,MAAM,KAC/DJ,GAAW,EACJ,IAAIC,SAAQ,SAAUC,EAASG,GACpCP,EACGQ,MAAK,SAAUH,GACdD,EAAQ,CAAEC,MAAAA,EAAOC,MAAM,OAExBG,MAAMF,SAGZjB,OAAOC,eAAgB,kBACfI,QAfb,IAA4BK,EACtBE,EAZqBL,EAbAL,EACnBC,QA2DA,IAAIL,MAAM"}